#连接的利用方法


HTTP是一个应用层协议，基于TCP/IP。HTTP的连接，其实就是TCP连接，从头到尾都是。只不过在其实传递的数据包不是任意的二进制，而是HTTP规定好的数据包；数据的发送也不是任意的，而是一个请求一个响应（请求和响应一次，就是一个事务）。

我们关心连接，是因为它事关多事务情况下的性能。而在http中，处理多事务的连接有4种方法，并行连接，Keep-Alive，持久连接，管线(pipeline)。

我们拿一个简单的文件作为多事务的案例：


    <html>
    <body>
      <h1>image/<h1>
      <img src="2.png"/>
      <img src="3.png"/>
    </body>
    </html>  

即使如此简单的文件，其实完全获取资源并呈现给客户也需要三个事务。分别用来获取1.html,2.png,3.png文件。要重复三次“打开连接、客户端发送请求，服务器发送响应、关闭连接”的过程。当然，后面的两个请求图片的事务是依赖于第一个事务的，因为只有第一个事务完成，解析html后我们的浏览器才知道还有两个图片需要获取。我们来看不同的事务处理模型如何应对此组请求。

## 并行连接

HTTP 0.9版本中，连接就是一个事务，也只能是一个事务。要是我们访问如下1.HTML:
那么客户端会发送两个请求过去给客户端。首先获取1.html。是“打开连接、发送请求、获取响应、关闭”

    GET /1.HTML 

然后获取2.png。依然是“打开连接、发送请求、获取响应、关闭”

    GET /2.png

然后获取3.png。依然是“打开连接、发送请求、获取响应、关闭”

    GET /3.png


一个事务就是一个连接，因此多个事务就是多个连接。这个做法，不但是0.9可以这样做，1.1版本也是可以的。

当然这里说的是最简单情况。因为作为有限的计算资源，连接不能无限增长，也不应该有多少事务就建立多少连接。而是到了一定程度就需要共享了。不过，我们暂时不关心这些细节。我们关心的是，居然三个资源都在同一个服务器，请求也都来自一个客户端，是否可以重用既有的已经打开的连接，这样就省下了打开、关闭连接的开销呢？接下来的两种连接模型，都是出于这样的优化目的。

## keep-alive连接

keep-alive连接优化的方法是，如果客户端说希望保持连接，且服务器也希望保持，那么双方（客户端和服务器）在完成一个事务后，并不立刻关闭连接，而是保持它的打开状态，以便用于随后的事务。HTTP协议引入了Connection:keep-alive的头字段值，让双方都可以表达保持连接打开的意图。这样，上面的3个事务就变成了：

打开连接、发送请求、获取响应、但是不关闭

    GET /1.HTML 
    Connection:keep-alive

    ---------

    HTTP/1.1 200 OK
    Connection:keep-alive

    内容...

然后获取2.png。“使用现有连接、发送请求、获取响应、也不关闭”


    GET /2.png
    Connection:keep-alive

    ---------
    HTTP/1.1 200 OK
    Connection:keep-alive

    内容...

然后获取3.png。依然是“使用现有连接、发送请求、获取响应、关闭”

    GET /3.png
    ---------

    HTTP/1.1 200 OK

    内容...

最后一条事务，不在发送Connection:keep-alive，因此连接关闭。这样的效果就是后面的两个事务可以重用第一个事务建立的连接，从而省下两次打开和关闭连接的开销。这个做法，就是在HTTP/1.0的基础上做的改进。因此被称为HTTP/1.0+Keep-Alive。

##  持久连接

持久连接是对Keep-Alive的改进。两者的差别在于默认值的不同。持久连接通过头字段值Connection:close 来通知连接关闭，如果没有发送，就表示保持打开。持续连接默认保持，而Keep-Alive默认关闭。这就是两者的不同。再看同样的案例，在持久连接下的不同表现：

打开连接、发送请求、获取响应、但是不关闭


    GET /1.HTML 
    ---------

    HTTP/1.1 200 OK

    内容...

然后获取2.png。“使用现有连接、发送请求、获取响应、也不关闭”


    GET /2.png

    ---------
    HTTP/1.1 200 OK

    内容...


然后获取3.png。依然是“使用现有连接、发送请求、获取响应、关闭”

    GET /3.png
    Connection:close
    ---------

    HTTP/1.1 200 OK
    Connection:close
    内容...

重用连接方面，持久连接和Keep-alive一致。但是使用持久连接可以少发送两次Connection头字段。

## 管线

管线是在持久连接的基础上的又一次优化。持久连接内的事务还是逐个方式的，就是说，我发起一个请求，然后等待响应，响应收完了再发新的请求。而管线的做法是不同的，在这个模型下，客户端可以一次发出全部请求，然后按照发出的次序，一个个的收对应的响应。依然看案例：


首先获取1.html。打开连接、发送请求、获取响应、但是不关闭


    GET /1.HTML 
    ---------

    HTTP/1.1 200 OK

    内容...

然后解析完成1.html，浏览器发现要完整呈现还需要两个资源。2.png,和3.png。这时就有差别了。浏览器会同时发出两个GET请求，而服务器会按照请求的次序，发送两个响应回来。这样，事务显得是重叠起来了。


    GET /2.png

    GET /3.png
    Connection:close
    ---------
    HTTP/1.1 200 OK

    内容...

    HTTP/1.1 200 OK
    Connection:close

    内容...

这就是管线模式和持久连接的不同。在高时延网络条件下，这样做可以降低网络时间。

嗯，这就是4种处理多事务的连接模型的差别。
## 实验：管线连接的能力的验证
用过telnet和echo的组合，同时发送两个资源请求到Node Http服务器，查看服务器的是否有效返回响应。

    cd code 
    node pipeline.js
然后执行命令

    $(echo -en "GET /1 HTTP/1.1\n\nGET /2 HTTP/1.1\n\n"; sleep 10) | nc localhost 3000


