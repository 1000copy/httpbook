# Connnection

HTTP is an application layer protocol based on TCP/IP. The HTTP connection is actually a TCP connection, from start to finish. However, the actual data packet is not an arbitrary binary, but a packet specified by HTTP; the data is not sent arbitrarily, but a request for a response (a request and a response is a transaction).

We care about connectivity because it is about performance in a multi-transaction situation. In HTTP, there are four methods for handling multi-transaction connections:

1. parallel connections
2. Keep-Alive
3. persistent connections
4. and pipelines.

We take a simple file as a multi-transaction case:

    <html>
    <body>
      <h1>image/<h1>
      <img src="2.png"/>
      <img src="3.png"/>
    </body>
    </html>  

Even with such a simple scenes, three transactions are required to fully capture the resources and present them to the client. Used to get `1.html`, `2.png`, `3.png` files respectively. Repeat the process of "opening the connection, sending the client request, the server sending a response, closing the connection" three times. Of course, the latter two request pictures of the transaction is dependent on the first transaction, because only the first transaction is completed, after parsing the HTML, our browser knows that there are still two pictures to be obtained. Let's see how different transaction models should respond to this group request.

## Parallel Connections

HTTP 0.9版本中，连接就是一个事务，也只能是一个事务。要是我们访问如下1.HTML:
那么客户端会发送两个请求过去给客户端。首先获取1.html。是“打开连接、发送请求、获取响应、关闭”

    GET /1.HTML 

然后获取2.png。依然是“打开连接、发送请求、获取响应、关闭”

    GET /2.png

然后获取3.png。依然是“打开连接、发送请求、获取响应、关闭”

    GET /3.png


一个事务就是一个连接，因此多个事务就是多个连接。这个做法，不但是0.9可以这样做，1.1版本也是可以的。

当然这里说的是最简单情况。因为作为有限的计算资源，连接不能无限增长，也不应该有多少事务就建立多少连接。而是到了一定程度就需要共享了。不过，我们暂时不关心这些细节。我们关心的是，居然三个资源都在同一个服务器，请求也都来自一个客户端，是否可以重用既有的已经打开的连接，这样就省下了打开、关闭连接的开销呢？接下来的两种连接模型，都是出于这样的优化目的。

## keep-alive连接

keep-alive连接优化的方法是，如果客户端说希望保持连接，且服务器也希望保持，那么双方（客户端和服务器）在完成一个事务后，并不立刻关闭连接，而是保持它的打开状态，以便用于随后的事务。HTTP协议引入了Connection:keep-alive的头字段值，让双方都可以表达保持连接打开的意图。这样，上面的3个事务就变成了：

打开连接、发送请求、获取响应、但是不关闭

    GET /1.HTML 
    Connection:keep-alive

    ---------

    HTTP/1.1 200 OK
    Connection:keep-alive

    内容...

然后获取2.png。“使用现有连接、发送请求、获取响应、也不关闭”


    GET /2.png
    Connection:keep-alive

    ---------
    HTTP/1.1 200 OK
    Connection:keep-alive

    内容...

然后获取3.png。依然是“使用现有连接、发送请求、获取响应、关闭”

    GET /3.png
    ---------

    HTTP/1.1 200 OK

    内容...

最后一条事务，不在发送Connection:keep-alive，因此连接关闭。这样的效果就是后面的两个事务可以重用第一个事务建立的连接，从而省下两次打开和关闭连接的开销。这个做法，就是在HTTP/1.0的基础上做的改进。因此被称为HTTP/1.0+Keep-Alive。

##  持久连接

持久连接是对Keep-Alive的改进。两者的差别在于默认值的不同。持久连接通过头字段值Connection:close 来通知连接关闭，如果没有发送，就表示保持打开。持续连接默认保持，而Keep-Alive默认关闭。这就是两者的不同。再看同样的案例，在持久连接下的不同表现：

打开连接、发送请求、获取响应、但是不关闭


    GET /1.HTML 
    ---------

    HTTP/1.1 200 OK

    内容...

然后获取2.png。“使用现有连接、发送请求、获取响应、也不关闭”


    GET /2.png

    ---------
    HTTP/1.1 200 OK

    内容...


然后获取3.png。依然是“使用现有连接、发送请求、获取响应、关闭”

    GET /3.png
    Connection:close
    ---------

    HTTP/1.1 200 OK
    Connection:close
    内容...

重用连接方面，持久连接和Keep-alive一致。但是使用持久连接可以少发送两次Connection头字段。

## 管线

管线是在持久连接的基础上的又一次优化。持久连接内的事务还是逐个方式的，就是说，我发起一个请求，然后等待响应，响应收完了再发新的请求。而管线的做法是不同的，在这个模型下，客户端可以一次发出全部请求，然后按照发出的次序，一个个的收对应的响应。依然看案例：


首先获取1.html。打开连接、发送请求、获取响应、但是不关闭


    GET /1.HTML 
    ---------

    HTTP/1.1 200 OK

    内容...

然后解析完成1.html，浏览器发现要完整呈现还需要两个资源。2.png,和3.png。这时就有差别了。浏览器会同时发出两个GET请求，而服务器会按照请求的次序，发送两个响应回来。这样，事务显得是重叠起来了。


    GET /2.png

    GET /3.png
    Connection:close
    ---------
    HTTP/1.1 200 OK

    内容...

    HTTP/1.1 200 OK
    Connection:close

    内容...

这就是管线模式和持久连接的不同。在高时延网络条件下，这样做可以降低网络时间。

嗯，这就是4种处理多事务的连接模型的差别。
## 实验：管线连接的能力的验证
用过telnet和echo的组合，同时发送两个资源请求到Node Http服务器，查看服务器的是否有效返回响应。

    cd code 
    node pipeline.js
然后执行命令

    $(echo -en "GET /1 HTTP/1.1\n\nGET /2 HTTP/1.1\n\n"; sleep 10) | nc localhost 3000


