
400 系列响应消息都是用来由服务器告诉客户端，收到的请求是它无法处理的。比如最常用的404 Not Found可以用来指示客户端请求的资源在服务器上根本没有。

400系列数量众多，但是大部分都比较简单。所以我只会把  412、417、403 单列出来做特别说明，因为前两个错误相对而言和协议的其他特性耦合比较多，因此显得复杂，并且对于设计良好的Restful app来说也是比较实用的。第三个状态码比较常见，但是标准定义比较抽象，我希望把它可以具体化一点。

#412 Precondition Failed 

客户端发起了条件请求，服务器发现这个请求中的其中一个条件并不成立，那么服务器就会用此错误码作为响应消息的状态码返回给客户端。

请求头上可以使用如下字段对请求做出条件限定：

    If-Match
    If-Modified-Since
    If-None-Match
    If-Range
    If-Unmodified-Since

这些请求头被称为前条件。通过它们可以告诉服务器只有条件满足才去完成请求的执行。

举个例子。假设我们GET了一个资源，在客户端由用户修改后提交更新。那么我们肯定希望在更新资源之前首先询问服务器此资源在 GET 后到更新之前是否有改动。如果有了改动，就说明另一个用户已经修改它了，我们当前的更新就不应该执行，否则就可能会导致不一致的事务了。具体的做法就是使用 POST 方法请求去更新资源的状态，并加上  If-Unmodified-Since 限定只有你最近GET资源之后此资源没有被修改的这个条件满足才去执行更新。而服务器可以校验此条件，如果这个条件没有满足，那么返回状态码412 (Precondition Failed) 即可。


#417 Expectation Failed

客户端在请求头内加入了Expect字段，这个字段要求的期望如果并不能被服务器支持，那么服务器会返回417 状态码给客户端。

案例：

    GET /todo/1 HTTP/1.1
    Host: example.org
    Content-Type:json
    Expect: 100-continue

    HTTP/1.1 417 Expectation Failed

#403 Fobidden

服务器禁止提供资源来响应它，尽管客户端的请求是有效的。相对而言，401 Unauthorized响应只要客户端提供授权就可以得到资源；403 fobidden 是即使客户端给了用户授权也是不行的。那么到底是什么原因禁止呢？标准在此处是沉默的。看到这个状态码，作为客户除了离开或者重试外，其实并不知道到底出了什么错，也不知道如何解决。为了希望用户不太困惑，有人为此错误给出了更加详细的子错误码——这是微软的IIS服务器的做法。这里给出了子错误码的局部列表：

    403.1 - Execute access forbidden 
    403.2 - Read access forbidden 
    403.3 - Write access forbidden 
    403.4 - SSL required. 
    403.5 - SSL 128 required. 
    403.6 - IP address rejected 
    403.7 - Client certificate required. 
    403.8 - Site access denied 
    403.9 - Too many users 


对程序员来说，这些状态子码，大部分可以一眼看明白它的含义，因此这套错误码可以帮助对403 Fobidden 的本意做出更加清晰的了解。所以尽管它们并不是标准的一部分，也依然是值得去学习和了解的。 对于用户而言，仅仅看到403 fobidden 而不去了解细节或许是更好的选择。

更多的400系列的错误码是比较简单的，其中大部分都是可以望文生义的了解到它的错误场景。比如411 Lengh Required 就是告诉客户端你的请求必须有Content-Length首部。401 Unauthorize 则是告诉客户端当前访问的资源需要认证，请提供用户名和密码过来。这里就不详述了。
 